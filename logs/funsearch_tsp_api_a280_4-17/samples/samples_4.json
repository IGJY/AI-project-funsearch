{"sample_order": 4, "function": "def priority(current_city: int, distances: np.ndarray, unvisited: set[int]) -> np.ndarray:\n    cities = np.array(list(unvisited), dtype=np.int64)\n    priorities = np.zeros(len(cities), dtype=np.float64)\n\n    for i in range(len(cities)):\n        city = cities[i]\n        dist = distances[current_city, city]\n        \n        # Factor 1: Inverse distance (closer cities should have higher priority)\n        inverse_distance = 1.0 / (1.0 + dist)\n        \n        # Factor 2: Average distance from the city to all others (cities with fewer connections should have higher priority)\n        avg_distance = np.mean(distances[city])\n        \n        # Factor 3: Distance to the closest unvisited city (cities that are closer to the \"center\" should have higher priority)\n        closest_distance = np.min(distances[city, list(unvisited)])\n\n        # Combine factors with weighted importance\n        priorities[i] = inverse_distance * (1.0 / (1.0 + avg_distance)) * (1.0 / (1.0 + closest_distance))\n\n    return priorities\n\n", "score": -Infinity}