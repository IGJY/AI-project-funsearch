{"sample_order": 2, "function": "def priority(current_city: int, distances: np.ndarray, unvisited: set[int]) -> np.ndarray:\n    cities = np.array(list(unvisited), dtype=np.int64)\n    priorities = np.zeros(len(cities), dtype=np.float64)\n\n    for i in range(len(cities)):\n        city = cities[i]\n        dist = distances[current_city, city]\n        \n        # Inverse of the distance: closer cities get higher priority\n        dist_priority = 1.0 / (dist + 1e-6)  # Add small epsilon to avoid division by zero\n        \n        # Consider the number of unvisited cities connected to the current city\n        connectivity = np.sum(distances[city] < np.inf)  # Number of cities with a valid connection\n        connectivity_priority = 1.0 / (connectivity + 1e-6)  # Inverse of connectivity for higher priority\n        \n        # Combine the priorities using a weighted sum\n        priorities[i] = dist_priority * connectivity_priority\n\n    return priorities\n\n", "score": -3148.1099349344036}