{"sample_order": 7, "function": "def priority(current_city: int, distances: np.ndarray, unvisited: set[int]) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1` with novel strategy.\"\"\"\n    cities = np.array(list(unvisited), dtype=np.int64)\n    priorities = np.zeros(len(cities), dtype=np.float64)\n\n    for i in range(len(cities)):\n        city = cities[i]\n        dist = distances[current_city, city]\n        \n        # Inverse of the distance: closer cities get higher priority\n        dist_priority = 1.0 / (dist + 1e-6)  # Add small epsilon to avoid division by zero\n        \n        # Consider the average distance to all unvisited cities\n        avg_dist = np.mean(distances[city, list(unvisited)])\n        avg_dist_priority = 1.0 / (avg_dist + 1e-6)  # Inverse of the average distance\n\n        # Combine the priorities with a stronger weight for average distance to unvisited cities\n        priorities[i] = dist_priority * avg_dist_priority\n\n    return priorities\n\n", "score": -Infinity}