{"sample_order": 9, "function": "def priority(current_city: int, distances: np.ndarray, unvisited: set[int]) -> np.ndarray:\n    cities = np.array(list(unvisited), dtype=np.int64)\n    priorities = np.zeros(len(cities), dtype=np.float64)\n\n    for i in range(len(cities)):\n        city = cities[i]\n        dist = distances[current_city, city]\n        dp = -dist  # Current city to target city distance (negative for closer cities to have higher priority)\n        \n        # Calculate connectivity based on inverse of the distance sum for the target city\n        connectivity = np.sum(distances[city, list(unvisited)]) / len(unvisited)\n        \n        # Combine distance and connectivity with a weighted balance\n        priorities[i] = dp * (1.0 / (1.0 + connectivity))\n\n    return priorities\n\n", "score": -Infinity}